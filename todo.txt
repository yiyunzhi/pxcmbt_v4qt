-------------qtads-------------
done: componentsFactory
done: repolishstyle
done: indicator not been right drawn
done: dockSplitter color not painted
done: tab not right been drawn
done: titlebar seems not right displayed
done: titlebar menu not right displayed
done: tab not focused while dock content get focused
done: autoHideTab initial in top area???
done: auto hide tab could not restore: sideTabWidget not destroyed while removed from layout
done: test EnumDockMgrConfigFlag.DragPreviewShowsContentPixmap in DOCK_MANAGER_DEFAULT_CONFIG in floating_drag_preview.py
done: floatDock zindex not right
done: tab->floating there a strange over on the mainwindow
done: test window destroy
done: test layout store and restore
done: test restoreContainer in dockmanager
done: test central widget
done: test add floating widget

done: auto hide tab style not good: css property not define in class
done: auto hide collapsed  view can not resize: wrong implementation
done: tabtitlebar maxheight and size not overlap
todo: import for typing checking ugly
todo: event hook while destroy??
done: make dockmanager inherit or using individual stylesheet
-------------theme--------------
done: separator in menubar ugly
done: replace standard icon
done: style for qtads
done: splash window
done: copy pin, detach, arrowdown, to theme folder
done: paletteChangeEvent not triggert or three times. use custom event instead.
done: use weakref of icon in a global registry, if theme changed then change the icon color in weakref.
-------------app--------------
todo: ->doing: selector: welcome,model,blocks,requirements(in docu group or testsuite???),
    testsuite,test-executor??,docu(test result in testexecutor group),extends(function in define group)
    ,define, -spacer- help
done: improve QTADS while darktheme setup
done: left put a mode select sidebar, default only centraldockarea
done: mode selector in group, every action from same group will in tabWidget grouped.
todo: help doc: https://doc.qt.io/qtforpython/overviews/qthelp-framework.html
todo: toggle toolbar https://doc.qt.io/qtforpython/PySide6/QtWidgets/QToolBar.html?highlight=toggleviewaction#PySide6.QtWidgets.PySide6.QtWidgets.QToolBar.toggleViewAction
        https://stackoverflow.com/questions/25277060/how-do-you-hide-restore-a-toolbar-when-switching-from-to-a-page-of-a-qstackedwid
done: STC Editor https://gist.github.com/Axel-Erfurt/8c84b5e70a1faf894879cd2ab99118c2
todo: event in a host during the design phase is only an interface, if events host add to the model, then could bind event with the events from other model emitted.
        in solution do a declaration of an event.
todo: has builtin fn solution: sendEvent
todo: IPODEntity muss have RT,IPOD
todo: model only accepted IPODEntity while DND
todo: tester only accepted IPODEntityModel while DND, create Test[Testrun,ReqLink]->drop IPODEntityModel->setting etc.constraint...->build testcase->run
-----------
----------------------docu-------------------------
several technologies and tools that are commonly used for model-based testing (MBT). Some of the most common ones include:

Model creation tools: These tools are used to create the models that will be used for testing. They can be based on various
modeling languages, including UML, SysML, and statecharts.

todo: Model checking tools: These tools are used to verify that the models are correct and complete, and that they accurately represent
      the intended behavior of the system.
      model checking tools available, including:
        SPIN: SPIN is a popular tool used to verify software and hardware systems. It supports the modeling of concurrent and
        asynchronous systems, and it can check safety and liveness properties.

        NuSMV: NuSMV is a symbolic model checker that can verify safety, liveness, and fairness properties of a system.
        It is often used to verify hardware designs and protocols.

        UPPAAL: UPPAAL is a tool that can model and verify systems with both discrete and continuous behavior. It is often
        used to verify real-time systems and protocols.

        PRISM: PRISM is a probabilistic model checker that can be used to verify properties of probabilistic systems, such as
        Markov decision processes and stochastic games.

        FDR: FDR is a refinement checker that can verify that a high-level model of a system correctly implements a low-level model.

        checking algorithum:
        Breadth-First Search (BFS): This algorithm explores all possible states of the system in a breadth-first manner,
        starting from the initial state. It can be used to check safety properties of a system.

        Depth-First Search (DFS): This algorithm explores the system state space in a depth-first manner. It can be used to
        verify liveness properties of a system.

        Symbolic Model Checking: This approach represents the system state space symbolically, allowing for more efficient
        exploration of large state spaces.

        Model Checking with Abstraction: This approach involves building an abstract model of the system that preserves the
        relevant properties of the original model. The abstract model can then be verified more efficiently.

        Counterexample-Guided Abstraction Refinement (CEGAR): This is a technique that combines abstraction and refinement to
        improve the efficiency of model checking. It involves iteratively refining the abstract model based on counterexamples found during model checking.

todo:Test generation tools: These tools are used to generate test cases from the models. They can use a variety of algorithms and
        techniques to ensure that the tests are comprehensive and cover all possible behaviors of the system.
        There are several test generation techniques and tools available, including:

        Model-Based Testing (MBT): MBT involves generating test cases directly from a model of the system under test.
        The model can be either abstract or concrete, and can be created using a modeling language such as UML or SysML.
        MBT tools can automatically generate test cases based on the model, and can also provide coverage metrics to
        ensure that the generated test cases cover all aspects of the model.
        Finite State Machine (FSM) based techniques: These techniques use the state machine model of the system to generate
        test cases. The model is traversed by executing all possible transitions between states and generating test cases for each path.

        Combinatorial techniques: These techniques generate test cases by selecting combinations of input values from the model.
        This can be done using techniques such as Pairwise Testing, Orthogonal Array Testing, and other combinatorial testing techniques.

        Constraint-based techniques: These techniques generate test cases by solving a set of constraints on the model.
        The constraints can be in the form of logical or arithmetic expressions, and the test cases are generated by satisfying these constraints.
        --> z3 symbolic Execution
        -->seq constrain:
        One way to constrain the order of generated test sequences is by defining a specific path through the model that represents the
        desired test sequence. This path can be defined using various techniques, such as statechart analysis or
        path finding algorithms, and can then be used to generate the test cases in the desired order. Another
        approach is to use combinatorial testing methods to systematically generate all possible combinations of inputs,
        which can then be ordered according to specific criteria.

        Random testing techniques: These techniques generate test cases by randomly selecting inputs from the model. The
        randomness can be guided by heuristics or statistical methods to ensure that the test cases are effective.



        Random Testing: This approach involves generating test cases randomly, without any specific input or model.
        Random testing can be effective in identifying edge cases and unexpected behaviors, but can also result in a large number of irrelevant test cases.

        Symbolic Execution: This technique involves generating test cases by exploring all possible execution paths
        through a program, and can be used to identify specific inputs that cause a program to fail. Symbolic execution
        can be useful in identifying hard-to-find bugs and vulnerabilities, but can also be computationally expensive.

        Combinatorial Testing: This approach involves generating test cases that cover all possible combinations of input
        parameters for a given system. Combinatorial testing can be used to ensure that all possible combinations of inputs
        are tested, but can also result in a large number of test cases.

        Fuzz Testing: This approach involves generating test cases by providing invalid or unexpected inputs to a system,
        in order to identify vulnerabilities and unexpected behaviors. Fuzz testing can be effective in identifying security
        vulnerabilities and other types of unexpected behaviors, but can also be time-consuming and computationally expensive.

todo:Test execution tools: These tools are used to execute the generated tests and collect the results. They can be integrated
     with various testing frameworks, such as JUnit or NUnit, to provide automated testing capabilities.
     In Python, there are several test execution tools that you can use to run your tests and collect the results. Some of the most popular ones include:
     unittest: This is the built-in testing framework in Python. It provides a simple and easy-to-use way to write and run tests.
        You can create test cases by subclassing the unittest.TestCase class, and then use the assert* methods to check the results of your tests.
     pytest: This is another popular testing framework in Python. It offers a more concise and expressive syntax for writing tests,
        and provides powerful features like fixtures, parameterization, and plugins. You can write tests as functions or methods, and use
        the assert statement to check the results.
     nose: This is a third-party testing framework that extends the functionality of unittest and provides additional features like test
        discovery, plugins, and test generators. You can use it to run tests written with unittest or pytest, and it also supports other
        testing frameworks like doctest and Selenium.
     To use any of these frameworks for test execution, you typically create a test suite that includes all the test cases you
     want to run, and then run the suite using a test runner. The runner will execute the tests, report the results,
     and generate any necessary output. You can also integrate the test execution with your development process using tools
     like continuous integration (CI) servers, which can automatically run the tests when new code is committed to the repository.

Test management tools: These tools are used to manage the test cases, test results, and other testing artifacts. They
can help to organize and track the testing process, and to ensure that all necessary tests have been executed.

Overall, the goal of these tools and technologies is to provide a systematic and efficient approach to testing, using
models as a key input to the testing process.

----------------------docu-------------------------
model execution algorithum:

Depth-First Search (DFS): This algorithm is used to traverse the graph in a depth-first manner,
    visiting all the nodes in a branch before backtracking. It can be used to generate a sequence of
    actions or events to be executed by the system.

Breadth-First Search (BFS): This algorithm is used to traverse the graph in a breadth-first manner,
    visiting all the nodes at a given level before moving on to the next level. It can be used to explore
    the entire graph and find all possible paths between nodes.

Dijkstra's Algorithm: This algorithm is used to find the shortest path between two nodes in a weighted
    graph. It can be used to optimize the execution of a model by finding the most efficient path between blocks.

A* Search: This algorithm is a more efficient version of Dijkstra's Algorithm that uses heuristics
    to guide the search. It can be used to find the shortest path between nodes while taking into account
    the estimated distance to the goal node.

!!Topological Sort: This algorithm is used to order the nodes in a graph such that all the dependencies
    of a node come before the node itself. It can be used to ensure that blocks are executed in the correct
    order and that there are no circular dependencies.


One algorithm that could be used for simulating such a model is the discrete event simulation algorithm.
This algorithm involves advancing the simulation time in discrete steps, where each step represents an event. During each step,
the simulation updates the state of the system by executing the blocks that are ready to execute and propagating the signals
that have been triggered. The simulation can also keep track of the timing constraints of the system to ensure that the behavior
of the model is consistent with the requirements.

Another approach is to use a rule-based approach where the behavior of the blocks is defined by a set of rules that
describe how the block behaves based on its inputs and internal state. The rules can be specified using a domain-specific
language (DSL) or a declarative language such as Prolog. The simulation would execute the rules in a specific order
to generate the output of the system.


ModelRuntimeAttributes:

The attributes necessary for a model runtime class would depend on the specific requirements of the modeling framework and the type of
model being used. However, some possible attributes that could be necessary for a model runtime class might include:

Model structure: This would include the high-level structure of the model, such as the number and types of components or modules,
the relationships between them, and the control flow of the model.

State information: This would include any relevant state information for the model, such as the current state of each component or module,
any data values or parameter settings, and any other relevant contextual information.

Execution status: This would include information on the current state of the model execution, such as whether the model is running or paused,
whether any errors or warnings have been encountered, and any relevant performance metrics or other execution information.

Interface information: This would include information on how the model interacts with external systems, including any input or output data streams,
communication protocols or APIs, and any other relevant information about how the model interacts with the larger system.

User-defined attributes: Depending on the needs of the specific modeling framework, it may be necessary to include additional user-defined attributes
that are relevant to the particular model being used.